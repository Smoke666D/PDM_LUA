#include "luaDefScript.h"
const char* const defaultLuaScript = " delayms=0 DOut={flase,true,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase,flase}DInput={flase,true,flase,flase,flase,flase,flase,flase,flase,flase,flase}Cur={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}function Yield()delayms,DInput[1],DInput[2],DInput[3],DInput[4],DInput[5],DInput[6],DInput[7],DInput[8],DInput[9],DInput[10],DInput[11],Cur[1],Cur[2],Cur[3],Cur[4],Cur[5],Cur[6],Cur[7],Cur[8],Cur[9],Cur[10],Cur[11],Cur[12],Cur[13],Cur[14],Cur[15],Cur[16],Cur[17],Cur[18],Cur[19],Cur[20]=coroutine.yield(DOut[20],DOut[19],DOut[18],DOut[17],DOut[16],DOut[15],DOut[14],DOut[13],DOut[12],DOut[11],DOut[10],DOut[9],DOut[8],DOut[7],DOut[6],DOut[5],DOut[4],DOut[3],DOut[2],DOut[1])end function boltoint(data)return(data)and 1 or 0 end function getDelay()return delayms end function getDIN(ch)return(ch<11)and DInput[ch] or false end function igetDIN(ch)return(ch<11)and boltoint(DInput[ch])or 0 end function getCurrent(ch)return Cur[ch] end function getCurFB(ch)return(Cur[ch]//1)end function getCurSB(ch)return(Cur[ch]*100)%100//1 end function setOut(ch,data)if ch<=20 then DOut[ch]=data; end end function waitDIN(ch,data,timeout)del=0 while true do Yield()if getDIN(ch)==data then return true end del=del+delayms if(timeout>0)then if(del>timeout)then return false end end end return false end KeyPad8={}KeyPad8.__index=KeyPad8 function KeyPad8:new(addr)local obj={key=0x00,ADDR=addr,new=true,tog=0x00,old=0x00,ledRed=0x00,ledGreen=0x00,ledBlue=0x00,temp={0},backligth=0,led_brigth=0}setmetatable(obj,self)setCanFilter(0x180+addr)return obj end function KeyPad8:process()if(GetCanToTable(0x180+self.ADDR,self.temp)==1)then self.tog=(~self.key&self.temp[1])~self.tog self.key=self.temp[1] end if self.new==true then self.new=false CanSend(0x200+self.ADDR,self.ledRed,self.ledGreen,self.ledBlue,0,0,0,0,0)end end function KeyPad8:getKey(n)return(self.key&(0x01<<(n-1)))~=0 end function KeyPad8:getToggle(n)return(self.tog&(0x01<<(n-1)))~=0 end function KeyPad8:resetToggle(n,state)if state==true then self.tog=(~(0x01<<(n-1)))&self.tog end end function KeyPad8:setLedRed(n,state)self.old=(state)and self.ledRed|(0x01<<(n-1))or self.ledRed&(~(0x01<<(n-1)))if(self.old~=self.ledRed)then self.ledRed=self.old self.new=true end end function KeyPad8:setLedGreen(n,state)self.old=(state)and self.ledGreen|(0x01<<(n-1))or self.ledGreen&(~(0x01<<(n-1)))if(self.old~=self.ledGreen)then self.ledGreen=self.old self.new=true end end function KeyPad8:setLedBlue(n,state)self.old=(state)and self.ledBlue|(0x01<<(n-1))or self.ledBlue&(~(0x01<<(n-1)))if(self.old~=self.ledBlue)then self.ledBlue=self.old self.new=true end end function KeyPad8:setLedWhite(n,state)self:setLedBlue(n,state)self:setLedGreen(n,state)self:setLedRed(n,state)end function KeyPad8:setLedBrigth(brigth)if(self.ledbrigth~=brigth)then self.ledbrigth=brigth CanSend(0x600+self.ADDR,0x2F,0x03,0x20,0x01,brigth,0,0,0)end end function KeyPad8:setBackLigthBrigth(brigth)if(self.backligth~=brigth)then self.backligth=brigth CanSend(0x600+self.ADDR,0x2F,0x03,0x20,0x02,brigth,0,0,0)end end CanInput={}CanInput.__index=CanInput function CanInput:new(addr)local obj={ADDR=addr,data={0,0,0,0,0,0,0,0}}setmetatable(obj,self)setCanFilter(addr)return obj end function CanInput:process()GetCanToTable(self.ADDR,self.data)end function CanInput:getBit(nb,nbit)return((self.data[nb]&(0x01<<(nbit-1)))>0)and true or false end function CanInput:getByte(nb)return self.data[nb] end function CanInput:getWord(nb)return self.data[nb]<<8|self.data[nb+1] end CanOut={}CanOut.__index=CanOut function CanOut:new(addr,time,size,d1,d2,d3,d4,d5,d6,d7,d8)local obj={ADDR=addr,data={d1,d2,d3,d4,d5,d6,d7,d8},delay=time,timer=0,sz=size}setmetatable(obj,self)return obj end function CanOut:process()self.timer=self.timer+getDelay()if self.timer>=self.delay then CanTable(self.ADDR,self.sz,self.data)self.timer=0 end end function CanOut:setFrame(...)local arg=table.pack(...)if(arg.n<9)then for i=1,arg.n do self.data[i]=arg[i] end self.sz=arg.n end end function CanOut:setBit(nb,nbit,state)if state==true then self.data[nb]=self.data[bn]|(0x01<<(nbit-1))else self.data[nb]=self.data[bn]&~(0x01<<(nbit-1))end end function CanOut:setByte(nb,state)self.data[nb]=state&0xFF end function CanOut:setWord(nb,state)self.data[nb]=(state<<8)&0xFF self.data[nb+1]=state&0xFF end CanRequest={}CanRequest.__index=CanRequest function CanRequest:new()local obj={del=0,timeout=0,data={0,0,0,0,0,0,0,0}}setmetatable(obj,self)return obj end function CanRequest:waitCAN(add,getadd,timeout,d1,d2,d3,d4,d5,d6,d7,d8)self.del=0 sendCandRequest(add,getadd,d1,d2,d3,d4,d5,d6,d7,d8)while true do Yield()if CheckAnswer()==1 then self.data[1],self.data[2],self.data[3],self.data[4],self.data[5],self.data[6],self.data[7],self.data[8]=GetRequest()return true end self.del=self.del+delayms if(timeout>0)then if(self.del>timeout)then return false end end end return false end function CanRequest:getData()return self.data[1],self.data[2],self.data[3],self.data[4],self.data[5],self.data[6],self.data[7],self.data[8] end Wipers={}Wipers.__index=Wiper function Wipers:new(pause,count)local obj={p=pause,c=count,out=false,timer=0,p_work=false,p_count=0,fsm=0}setmetatable(obj,self)return obj end function Wipers:process(ign,start,pause,location)if ign==true then if(pause==ture)then if self.fsm==0 then if location then self.p_work=true self.fsm=1 end elseif self.fsm==1 then if(not location)then self.fsm=2 end elseif self.fsm==2 then if location then self.p_count=self.p_count+1 if self.p_count>=self.c then self.fsm=3 self.p_work=flase else self.fsm=2 end end elseif self.fsm==3 then self.timer=self.timer+getDelay()if(self.timer>self.p)then self.timer=0 self.fsm=0 end end else self.fsm=0 self.timer=0 self.p_count=0 p_work=false end self.out=start or p_work or(not location)else self.out=false or(not location)end end function Wipers:getOut()return self.out end Counter={}Counter.__index=Counter function Counter:new(inMin,inMax,inDefault,inReload)local obj={counter=(type(inDefault)==\"number\")and inDefault or 0,min=(type(inMin)==\"number\")and inMin or 0,max=(type(inMax)==\"number\")and inMax or 0xFFFF,reload=(type(inReload)==\"boolean\")and inReload or true,old=false}setmetatable(obj,self)return obj end function Counter:process(inc,dec,rst)if(type(inc)==\"boolean\")and(type(dec)==\"boolean\")and(type(rst)==\"boolean\")then if(inc==true)then if(self.old==false)then if(self.counter<self.max)then self.counter=self.counter+1 elseif(self.reload==true)then self.counter=self.min end end end if(dec==true)then if(self.old==false)then if(self.counter>self.min)then self.counter=self.counter-1 elseif(self.reload==true)then self.counter=self.max end end end if(rst==true)then if(self.old==false)then self.counter=self.min end end self.old=(rst or inc or dec)and true or false end return end function Counter:get()return self.counter end Delay={}Delay.__index=Delay function Delay:new(inDelay,neg)local obj={counter=0,launched=false,output=not neg,delay=inDelay,state=neg,rst=true}setmetatable(obj,self)return obj end function Delay:process(start)if start==true then if self.rst==true then self.launched=true self.counter=0 end end self.rst=not start if(self.launched==true)then self.counter=self.counter+getDelay()if(self.counter<self.delay)then self.output=self.state else self.launched=false end else self.output=not self.state end return end function Delay:get()return self.output end TurnSygnals={}TurnSygnals.__index=TurnSygnals function TurnSygnals:new(inDelay)local obj={delay=(type(inDelay)==\"number\")and inDelay or 100,counter=0,state=true,outLeft=false,outRight=false,outAlarm=false}setmetatable(obj,self)return obj end function TurnSygnals:process(enb,left,right,alarm)if(type(enb)==\"boolean\")and(type(left)==\"boolean\")and(type(right)==\"boolean\")and(type(alarm)==\"boolean\")then if left or right or alarm then self.counter=self.counter+getDelay()if(self.counter>self.delay)then self.state=not self.state self.counter=0 end else self.state=true self.counter=0 end self.outLeft=left and self.state and enb and(not alarm)self.outRight=right and self.state and enb and(not alarm)self.outAlarm=alarm and self.state and enb end end function TurnSygnals:getRight()return self.outRight end function TurnSygnals:getLeft()return self.outLeft end function TurnSygnals:getAlarm()return self.outAlarm end init=function()setOutConfig(1,10,2000,60)setOutConfig(2,10,2000,60)setOutConfig(3,10,2000,60)setOutConfig(4,5,2000,60)setOutConfig(5,5,2000,60)setOutConfig(6,5,2000,60)setOutConfig(7,5,2000,60)setOutConfig(8,10,2000,60)setOutConfig(9,8,0,10)setOutConfig(10,8,0,10)setOutConfig(11,8,0,10)setOutConfig(12,8,0,10)setOutConfig(13,8,0,10)setOutConfig(14,8,0,10)setOutConfig(15,8,0,10)setOutConfig(16,8,0,10)setOutConfig(17,8,0,10)setOutConfig(18,8,0,10)setOutConfig(19,8,0,10)setOutConfig(20,8,0,10)setDINConfig(1,1)setDINConfig(2,1)setDINConfig(3,1)setDINConfig(4,1)setDINConfig(5,1)setDINConfig(6,1)setDINConfig(7,1)setDINConfig(8,1)setDINConfig(9,1)setDINConfig(10,1)setDINConfig(11,1)CAN_EXCHENGE=CanRequest:new()if(CAN_EXCHENGE:waitCAN(0x615,0x595,8000,0x2F,0x03,0x20,0x03,0x06,0x00,0x00,0x00)==true)then dd1,dd2,dd3,dd4,dd5,dd6,dd7,dd8=CAN_EXCHENGE:getData()if dd1==0x60 then setOut(13,true)end end end main=function()KeyPad=KeyPad8:new(0x15)TurnSygnal=TurnSygnals:new(500)Delay10s=Delay:new(10000,true)Delay8s=Delay:new(8000,true)Delay4s=Delay:new(4000,true)Delay3s=Delay:new(3000,true)Delay2s=Delay:new(2000,true)Delay1s=Delay:new(1000,true)LigthCounter=Counter:new(1,4,1,true)WiperCounter=Counter:new(1,3,1,true)CAN_OUT1=CanOut:new(0x505,900,8,0,0,0,0,0,0,0,0)CAN_OUT2=CanOut:new(0x506,900,8,0,0,0,0,0,0,0,0)CAN_OUT3=CanOut:new(0x507,900,8,0,0,0,0,0,0,0,0)CAN_OUT4=CanOut:new(0x508,900,8,0,0,0,0,0,0,0,0)CAN_OUT5=CanOut:new(0x509,900,8,0,0,0,0,0,0,0,0)CAN_OUT6=CanOut:new(0x510,900,8,0,0,0,0,0,0,0,0)CAN_TEMP=CanInput:new(0x028)CAN_RPM=CanInput:new(0x032)CAN_CH2=CanInput:new(0x511)CAN_CH3=CanInput:new(0x5F2)CAN_ALARM=CanInput:new(0x034)Wiper=Wipers:new(2000,3)wiperstart=false wiperpause=false lowbeam=false highbeam=false t=true temp=false starter=false ignition=false pre_heat_on=false can_temp=0 while true do KeyPad:process()CAN_CH2:process()CAN_RPM:process()CAN_CH3:process()starter=CAN_CH3:getBit(1,4)ignition=CAN_CH3:getBit(1,1)CAN_ALARM:process()CAN_OUT1:process()CAN_OUT2:process()CAN_OUT3:process()CAN_OUT4:process()CAN_OUT5:process()CAN_OUT6:process()CAN_TEMP:process()can_temp=CAN_TEMP:getByte(1)DIN_STATE=igetDIN(1)|igetDIN(2)<<1|igetDIN(3)<<2|igetDIN(4)<<3|igetDIN(5)<<4|igetDIN(6)<<5|igetDIN(7)<<6|igetDIN(8)<<7 DIN_STATE1=igetDIN(9)|igetDIN(10)<<1|igetDIN(11)<<2 CAN_OUT1:setFrame(DIN_STATE,DIN_STATE1)CAN_OUT2:setFrame(getCurFB(1),getCurSB(1),getCurFB(2),getCurSB(2),getCurFB(3),getCurSB(3),getCurFB(4),getCurSB(4))CAN_OUT3:setFrame(getCurFB(5),getCurSB(5),getCurFB(6),getCurSB(6),getCurFB(7),getCurSB(7),getCurFB(8),getCurSB(8))CAN_OUT4:setFrame(getCurFB(9),getCurSB(9),getCurFB(10),getCurSB(10),getCurFB(11),getCurSB(11),getCurFB(12),getCurSB(12))CAN_OUT5:setFrame(getCurFB(13),getCurSB(13),getCurFB(14),getCurSB(14),getCurFB(15),getCurSB(15),getCurFB(16),getCurSB(16))CAN_OUT6:setFrame(getCurFB(17),getCurSB(17),getCurFB(18),getCurSB(18),getCurFB(19),getCurSB(19),getCurFB(20),getCurSB(20))brigth=igetDIN(2)<<4 KeyPad:setBackLigthBrigth(brigth)Delay8s:process(ignition)Delay4s:process(ignition)Delay3s:process(ignition)Delay2s:process(ignition)Delay1s:process(ignition)pre_heat_on=(Delay8s:get()and(can_temp<40))or(Delay4s:get()and(can_temp<50))or(Delay3s:get()and(can_temp<60))or(Delay2s:get()and(can_temp<70))or(Delay1s:get()and(can_temp<100))setOut(12,pre_heat_on)fan_on=KeyPad:getToggle(4)or(ignition and(can_temp==0))or(can_temp>125)KeyPad:setLedGreen(4,KeyPad:getToggle(4))setOut(14,fan_on)Delay10s:process(starter)starter_on=Delay10s:get()and ignition and(CAN_RPM:getWord(1)<500)setOut(15,starter_on)setOut(11,ignition)setOut(16,ignition)setOut(1,KeyPad:getKey(1))KeyPad:setLedGreen(1,KeyPad:getKey(1))LigthCounter:process(KeyPad:getKey(2),false,false)lowbeam=(LigthCounter:get()==2)highbeam=(LigthCounter:get()==4)setOut(8,lowbeam)setOut(6,highbeam)KeyPad:setLedGreen(2,lowbeam)KeyPad:setLedBlue(2,highbeam)WiperCounter:process(KeyPad:getKey(8),false,false)wiperstart=(WiperCounter:get()==2)wiperpause=(WiperCounter:get()==3)setOut(2,KeyPad:getKey(8)and getDIN(2))KeyPad:setLedGreen(8,wiperstart)KeyPad:setLedBlue(8,wiperpause)setOut(5,wiperstart or wiperpause)TurnSygnal:process(true,KeyPad:getToggle(5),KeyPad:getToggle(6),KeyPad:getToggle(7))KeyPad:resetToggle(5,KeyPad:getToggle(7)or KeyPad:getKey(6))KeyPad:resetToggle(6,KeyPad:getToggle(7)or KeyPad:getKey(5))KeyPad:setLedWhite(5,TurnSygnal:getLeft())KeyPad:setLedWhite(6,TurnSygnal:getRight())KeyPad:setLedRed(7,TurnSygnal:getAlarm())KeyPad:setLedGreen(7,TurnSygnal:getAlarm())setOut(3,TurnSygnal:getLeft()or TurnSygnal:getAlarm())setOut(7,TurnSygnal:getRight()or TurnSygnal:getAlarm())KeyPad:setLedGreen(3,KeyPad:getToggle(3))Yield()end end ";
